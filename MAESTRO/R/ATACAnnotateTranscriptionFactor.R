#' Identify driver transcrition factors for scATAC-seq clusters
#'
#' Identify driver transcrition factors for scATAC-seq clusters based on TF ChIP-seq peaks from CistromeDB. To run this function, you must first install the giggle package (see from https://github.com/ryanlayer/giggle). 
#'
#' @docType methods
#' @name ATACAnnotateTranscriptionFactor
#' @rdname ATACAnnotateTranscriptionFactor
#' 
#' @param ATAC Seurat object of ATAC RPscore clustering generated by \code{\link{ATACAnnotateCelltype}} function.
#' @param peaks Data frame of differential peaks, generated by \code{\link{ATACRunSeurat}}, \code{\link{FindMarkersMAESTRO}} or \code{\link{FindAllMarkersMAESTRO}} function.
#' @param cluster The cluster of given diff-peaks. For example, if the diff-peaks are genrated using cluster 1,2,3 vs cluster 4,5,6, the cluster should be set as c(1,2,3,4,5,6).
#' @param project Output project name for the giggle analysis result. Default is the project name of the ATAC Seurat object
#' @param giggle.path Path of the giggle annotation files. The giggle annoation for CistromeDB is available at https://github.com/liulab-dfci/MAESTRO.
#' Download and unzip the annotation, supply the path of the annotations to \code{giggle.anno.path}.
#' @param organism Organism for the dataset. Only support "GRCh38" and "GRCm38". Default is "GRCh38".
#' @param top.tf Number of top TFs output for each cluster. Default if 10, for each cluster, output the top 10 enriched TFs.
#' @param target.genes Whether or not to output the target genes for top TFs. Default is FALSE.
#' @param min.peaks Minimum number of peaks requires to run giggle, default is 10.
#'
#' @author Dongqing Sun, Changxin Wan, Chenfei Wang
#'
#' @return A list of top enriched transcription factors and their target genes for each cluster. 
#'
#'
#' @examples
#' data(pbmc.ATAC)
#' data(pbmc.RP)
#' data(human.immune.CIBERSORT)
#' pbmc.ATAC.res <- ATACRunSeurat(inputMat = pbmc.ATAC, project = "PBMC.scATAC.Seurat", method = "LSI")
#' pbmc.ATAC.res$ATAC <- ATACAttachGenescore(pbmc.ATAC.res$ATAC, pbmc.RP)
#' pbmc.ATAC.res$ATAC <- ATACAnnotateCelltype(pbmc.ATAC.res$ATAC, human.immune.CIBERSORT, min.score = 0.1, genes.cutoff = 1E-3)
#' pbmc.tfs <- ATACAnnotateTranscriptionFactor(ATAC = pbmc.ATAC.res$ATAC, peaks = pbmc.ATAC.res$peaks, project = "PBMC.scATAC.TF", giggle.path = "/home/annotations/giggle")
#' pbmc.tfs
#'
#' @importFrom Seurat GetAssayData Idents DefaultAssay
#' @export

ATACAnnotateTranscriptionFactor <- function(ATAC, peaks, cluster = NULL, project = ATAC@project.name, giggle.path, organism = "GRCh38", top.tf = 10, target.genes = FALSE, min.peaks = 10)
{
  if(organism == "GRCh38"){
      data(GRCh38.CistromeDB.genescore)
      data(human.tf.family)
      geneScore <- GRCh38.CistromeDB.genescore
      tf_family_list <- HUMAN.TFFamily}
  if(organism == "GRCm38"){
      data(GRCm38.CistromeDB.genescore)
      data(mouse.tf.family)
      geneScore <- GRCm38.CistromeDB.genescore
      tf_family_list <- MOUSE.TFFamily}
  
  if("cluster" %in% colnames(peaks)){
    # peaks$cluster <- as.factor(peaks$cluster)
    peaks <- peaks[peaks$avg_logFC>0,]
    colnames(peaks)[7] = "peak"
    ifAllcluster = TRUE
  }else{
    ifAllcluster = FALSE
    if(is.null(cluster)){
      cluster = "unknown"
      warning("If you need to filter TFs by gene activity, please specify the cluster.")
    }
    peaks$cluster <- paste(cluster, collapse = ",")
    peaks$peak <- rownames(peaks)
  }
  
  if(nrow(peaks)<=50){
    message("Not enough differential peaks input and no driver TFs identified.")
    
    reg_table = data.frame(Cluster=Idents(ATAC), CelltypeAnnotation=ATAC@meta.data$assign.ident)
    row.names(reg_table) = NULL
    reg_table_unique = unique.data.frame(reg_table)
    reg_df = reg_table_unique
    reg_df$TF = "No TFs identified."
    reg_df$`log(Gigglescore)` = "NA"
    write.table(reg_df,paste0(project, ".PredictedTFTop", top.tf, ".txt"), col.names = TRUE, row.names = FALSE, sep = "\t", quote = FALSE)
    
    return(list())
  }else{
    targetList <- list()
    tfList <- list()
    antFile <- read.csv(paste0(giggle.path,"/CistromeDB.sample.annotation.txt"), sep="\t", row.names=1, stringsAsFactors = FALSE)  
    outputDir <- paste0(project, ".GIGGLE")
    if (!file.exists(outputDir)){
      dir.create(path=outputDir)
    } 
    for (icluster in unique(peaks$cluster)) {
      message(paste("Identify enriched TFs for cluster ", icluster, "..."))
      targetList[[icluster]] = list()
      ipeaks <- peaks[peaks$cluster == icluster, "peak"]
      if(length(ipeaks) > min.peaks){
      if(!file.exists(paste0(outputDir, "/", icluster, ".peaks.bed.giggle.res.tfs.txt"))){
      ipeaks <- strsplit(ipeaks, "\\W")
      ipeaks <- data.frame(matrix(unlist(ipeaks), nrow=length(ipeaks), byrow=T))
      outputBed <- paste0(outputDir, "/", icluster, ".peaks.bed")
      write.table(ipeaks, outputBed, sep="\t", quote = FALSE, row.names = FALSE, col.names = FALSE)
      targetDf = RunGiggle(peakbed = outputBed, giggle.path = giggle.path, organism = organism, antFile = antFile, type = 'tf')}
      else{
      targetDf = read.delim(paste0(outputDir, "/", icluster, ".peaks.bed.giggle.res.tfs.txt"), stringsAsFactors = FALSE)
      }
      if(nrow(targetDf) > 0){
        rownames(targetDf) = targetDf$factor
        tfList[[icluster]] <- targetDf[,c("factor","giggle_score")]
      }}
      else{
      message(paste("Skip identifying enriched TFs for cluster ", icluster, " because peak number is less than", min.peaks,"..."))
      }

    }
    tf_all=NULL
    for (icluster in unique(peaks$cluster))
    {
      fileName=paste0(outputDir,"/", icluster, ".peaks.bed.giggle.res.tfs.txt")
      if (file.exists(fileName))
      {
        tf_p=read.delim(fileName, stringsAsFactors = FALSE)
        tf_temp=data.frame(tf_p$giggle)
        rownames(tf_temp)=tf_p$factor
        colnames(tf_temp)=icluster
        if (is.null(tf_all)){tf_all = tf_temp}
        else {tf_all=multimerge(list(tf_all, tf_temp))}
      }
    }
    write.table(log10(tf_all+1),paste0(project,'.PredictedTFScore.txt'),sep='\t',quote = F)
    message("Identification of enriched TFs is done.")
    
    if(ifAllcluster){
      cluster_cell_list = split(names(Idents(ATAC)), Idents(ATAC))
    }else{
      cluster_cell_list = list()
      if(length(cluster) == 1 && cluster == "unknown"){
        cluster_cell_list[["unknown"]] = names(Idents(ATAC))
      }else{
        cluster_cell_list[[paste(cluster, collapse = ",")]] = names(Idents(ATAC))[Idents(ATAC) %in% cluster]
        cluster_cell_list[["others"]] = names(Idents(ATAC))[!(Idents(ATAC) %in% cluster)]
      }
    }
    
    DefaultAssay(ATAC) = "ACTIVITY"
    cluster_avg_rp = sapply(names(cluster_cell_list), function(x){
      return(Matrix::rowMeans(GetAssayData(object = ATAC)[, cluster_cell_list[[x]]]))
    })
    
    cluster_tf_list_filter = sapply(names(tfList), function(x){
      tf_family_filter = sapply(tfList[[x]][,1], function(y){
        if(y %in% names(tf_family_list) & length(intersect(tf_family_list[[y]], rownames(cluster_avg_rp))) > 1){
          tf_family_expr = cluster_avg_rp[intersect(tf_family_list[[y]], rownames(cluster_avg_rp)),x]
          tf_family_expr = tf_family_expr[which(tf_family_expr != 0.00)]
          tf_family = names(tf_family_expr)[order(tf_family_expr, decreasing=T)]
          return(list(tf_family,tfList[[x]][y,2]))
        }else{
          if(!(y %in% rownames(cluster_avg_rp)) || cluster_avg_rp[y,x] == 0.00){
            return(NULL)
          }else{
            return(list(y,tfList[[x]][y,2]))
          }
        }
      }, simplify = FALSE)
      if(length(which(sapply(tf_family_filter,is.null))) > 0){
        tf_family_filter = tf_family_filter[-which(sapply(tf_family_filter,is.null))]
      }
      tf_family_filter_tf = sapply(tf_family_filter,function(xx){
        return(xx[[1]])
      })
      tf_family_filter_score = unlist(sapply(tf_family_filter,function(xx){
        return(xx[[2]])
      }))

      tf_family_filter_dedup_tf = tf_family_filter_tf[!duplicated(tf_family_filter_tf)]
      tf_family_filter_dedup_score = tf_family_filter_score[!duplicated(tf_family_filter_tf)]
      listlen = sapply(tf_family_filter_dedup_tf, function(xx){
        length(xx)
      })

      tf_family_filter_desubset_tf = sapply(tf_family_filter_dedup_tf,function(xx){
        ifsubset = sapply(tf_family_filter_dedup_tf, function(yy){
          all(xx %in% yy)
        })
        return(tf_family_filter_dedup_tf[ifsubset][[which.max(listlen[ifsubset])]])
      })
      tf_family_filter_desubset_score = sapply(tf_family_filter_dedup_tf,function(xx){
        ifsubset = sapply(tf_family_filter_dedup_tf, function(yy){
          all(xx %in% yy)
        })
        return(max(tf_family_filter_dedup_score[ifsubset]))
      })

      tf_family_filter_desubset_dedup_tf = tf_family_filter_desubset_tf[!duplicated(tf_family_filter_desubset_tf)]
      tf_family_filter_desubset_dedup_score = tf_family_filter_desubset_score[!duplicated(tf_family_filter_desubset_tf)]
      tf_family_filter_desubset_dedup_tf_str = lapply(tf_family_filter_desubset_dedup_tf, function(xx){
        return(paste(xx, collapse = " | "))
      })
      return(list(tf = unlist(tf_family_filter_desubset_dedup_tf_str)[1:top.tf], score = tf_family_filter_desubset_dedup_score[1:top.tf]))
    })

    cluster_tf_list_filter_tf = cluster_tf_list_filter["tf",]
    cluster_tf_list_filter_score = cluster_tf_list_filter["score",]
    if(length(cluster_tf_list_filter_tf) == 1){
      names(cluster_tf_list_filter_tf) = colnames(cluster_tf_list_filter)
      names(cluster_tf_list_filter_score) = colnames(cluster_tf_list_filter)
    }
        
    if(!ifAllcluster){
      names(cluster_tf_list_filter_tf) = paste(cluster, collapse = ",")
      names(cluster_tf_list_filter_score) = paste(cluster, collapse = ",")
    }

    cluster_tf_df = reshape2::melt(cluster_tf_list_filter_tf)[,c(2,1)]
    colnames(cluster_tf_df) = c("Cluster","TF")
    cluster_score_df = reshape2::melt(cluster_tf_list_filter_score)[,c(2,1)]
    colnames(cluster_score_df) = c("Cluster","Gigglescore")
    cluster_tf_df[,"log(Gigglescore)"] = round(log10(cluster_score_df$Gigglescore), 2)

    if("assign.ident" %in% colnames(ATAC@meta.data)){
      if(ifAllcluster){
        reg_table = data.frame(Cluster = Idents(ATAC), CelltypeAnnotation = ATAC@meta.data$assign.ident)
        row.names(reg_table) = NULL
        celltype_count = table(reg_table)
        celltype_count_df = as.data.frame(celltype_count, stringsAsFactors = FALSE)
        celltype_dominate = sapply(unique(celltype_count_df$Cluster),function(x){
          celltype_count_df_cluster = celltype_count_df[celltype_count_df$Cluster == x,]
          celltype_dominate = celltype_count_df_cluster[which.max(celltype_count_df_cluster$Freq), "CelltypeAnnotation"]
        })
        reg_table_unique = data.frame(Cluster = names(celltype_dominate), CelltypeAnnotation = celltype_dominate)
      }else{
        if(length(cluster) == 1 && cluster == "unknown"){
          reg_table_unique = data.frame(Cluster = "unknown", CelltypeAnnotation = "unknown")
        }else{
          celltype = ATAC$assign.ident[names(Idents(ATAC))[Idents(ATAC) %in% cluster]]
          celltype_count = sort(table(celltype), decreasing = TRUE)
          celltype_dominate = names(celltype_count)[1]
          reg_table_unique = data.frame(Cluster = paste(cluster, collapse = ","), CelltypeAnnotation = celltype_dominate)
        }
      }
    }else{
      reg_table_unique = data.frame(Cluster = unique(cluster_tf_df$Cluster), CelltypeAnnotation = "unknown")
    }
    reg_df = merge(reg_table_unique, cluster_tf_df)
    write.table(reg_df,paste0(project, ".PredictedTFTop", top.tf, ".txt"), col.names = TRUE, row.names = FALSE, sep = "\t", quote = FALSE)
    
    if(target.genes){
    for(icluster in colnames(cluster_tf_list_filter)){
      message(paste("Identify target genes for the top ", top.tf, " TFs for cluster ", icluster, "..."))
      targetDf <- read.table(paste0(project, ".GIGGLE/", icluster, ".peaks.bed.giggle.res.tfs.txt"), sep="\t", header = TRUE, stringsAsFactors = FALSE, quote = "")
      tfs = cluster_tf_list_filter_tf[[icluster]]
      tfs = sapply(tfs, function(x){
        tf = unlist(strsplit(x, split = " | ", fixed = TRUE))[1]
        return(tf)
      })
      names(tfs) = NULL
      for (tf in tfs) {
        if(tf %in% targetDf$factor){
          dcid <- as.character(targetDf[targetDf$factor==tf, "sample_id"])
          tfTarget <- geneScore[["genes"]][geneScore[["indices"]][[dcid]]]
          write.table(data.frame(tfTarget), paste0(project, ".GIGGLE/", icluster, ".", tf, ".", dcid, ".target.genes.top500.txt"), sep="\t", quote=FALSE, row.names=FALSE, col.names=FALSE)
        }
      }
    }}
    tfListExpand = as.list(as.data.frame(cluster_tf_list_filter_tf, stringsAsFactors = FALSE))
    names(tfListExpand) = names(cluster_tf_list_filter_tf)
    return(tfListExpand)
  }
}

RunGiggle <- function(peakbed, giggle.path, organism, antFile, type = 'tf'){
  outputBed = peakbed
  cmd <- paste0("sort --buffer-size 2G -k1,1 -k2,2n -k3,3n ", outputBed, " | bgzip -c > ", outputBed, ".gz")
  system(cmd)
  cmd <- paste0("giggle search -i ", giggle.path, "/giggle.", organism, " -q ", outputBed, ".gz -s > ", outputBed, ".result.xls")
  system(cmd)
  resultDf <- read.table(paste0(outputBed, ".result.xls"), sep="\t", row.names=NULL, comment.char="", stringsAsFactors =  FALSE)
  resultDf <- resultDf[,-9]
  colnames(resultDf) <- c("file", "file_size", "overlaps", "odds_ratio", "fishers_two_tail", "fishers_left_tail", "fishers_right_tail", "combo_score")
  resultDf <- resultDf[resultDf$overlaps>0,]
  if(organism == "GRCh38"){
    rownames(resultDf) <- sapply(strsplit(resultDf$file, "human/"), function(x) return(gsub("_5foldPeak.bed.gz", "", x[2])))
  }
  if(organism == "GRCm38"){
    rownames(resultDf) <- sapply(strsplit(resultDf$file, "mouse/"), function(x) return(gsub("_5foldPeak.bed.gz", "", x[2])))
  }
  resultDf <- resultDf[,c("file_size", "overlaps", "combo_score")]
  targetDf <- merge(resultDf, antFile, by.x=0, by.y=0)
  colnames(targetDf) <- c("sample_id", "sample_peak_number", "overlap_peak_number", "giggle_score", "GSM_id", "species", "factor", "factor_type", "cell_line", "cell_type", "tissue", "disease")                          
  targetDf$biological_resource <- apply(targetDf, 1, function(x) return(paste0(x[9:11], collapse=";")))
  targetDf <- targetDf[, c("sample_id", "GSM_id", "species", "factor", "factor_type", "biological_resource", "giggle_score", "sample_peak_number", "overlap_peak_number")]
  targetDf_tf <- targetDf[targetDf$factor_type=='tf',]
  targetDf_tf <- targetDf_tf[order(-targetDf_tf$giggle_score), ]
  targetDf_tf <- targetDf_tf[!duplicated(targetDf_tf$factor), ]
  write.table(targetDf_tf, paste0(outputBed, ".giggle.res.tfs.txt"), sep="\t", quote=FALSE, row.names=FALSE)
  
  targetDf_ca <- targetDf[targetDf$factor_type=='ca',]
  ATAC_cluster <- read.csv(paste0(giggle.path,"/ATAC_with_log_peaks_RP_hierarchical_sample_80_clusters.csv"), sep=",", row.names=1, stringsAsFactors = FALSE)  
  DNase_cluster <- read.csv(paste0(giggle.path,"/DNAse_with_log_peaks_RP_hierarchical_sample_80_clusters.csv"), sep=",", row.names=1, stringsAsFactors = FALSE)  
  ATAC_cluster$combined <- apply(ATAC_cluster, 1, function(x) return(paste0(x[2:3], collapse="_")))
  ATAC_cluster$clusterinfo <-  apply(ATAC_cluster, 1, function(x) return(paste0(x[2:3], collapse="_")))
  for(i in 1:nrow(ATAC_cluster)){ATAC_cluster[i,'CistromeClusterInfo'] <- paste0(unique(ATAC_cluster[ATAC_cluster$CistromeCluster==ATAC_cluster[i,'CistromeCluster'],'combined']),collapse=";")}
  ATAC_cluster <- ATAC_cluster[,c('CistromeCluster','CistromeClusterInfo')]
  DNase_cluster$combined <- apply(DNase_cluster, 1, function(x) return(paste0(x[2:3], collapse="_")))
  DNase_cluster$clusterinfo <-  apply(DNase_cluster, 1, function(x) return(paste0(x[2:3], collapse="_")))
  for(i in 1:nrow(DNase_cluster)){DNase_cluster[i,'CistromeClusterInfo'] <- paste0(unique(DNase_cluster[DNase_cluster$CistromeCluster==DNase_cluster[i,'CistromeCluster'],'combined']),collapse=";")}
  DNase_cluster <- DNase_cluster[,c('CistromeCluster','CistromeClusterInfo')]
  ca_cluster <- rbind(ATAC_cluster, DNase_cluster)
  targetDf_ca <- merge(targetDf_ca, ca_cluster, by.x="sample_id", by.y=0)
  targetDf_ca <- targetDf_ca[order(-targetDf_ca$giggle_score), ]
  write.table(targetDf_ca, paste0(outputBed, ".giggle.res.cas.txt"), sep="\t", quote=FALSE, row.names=FALSE)

  cmd <- paste0("rm ", outputBed, ".gz")
  system(cmd)
  if(type == 'tf'){return(targetDf_tf)}
  if(type == 'ca'){return(targetDf_ca)}
}

multimerge <- function (mylist) {
  ## mimics a recursive merge or full outer join
 
  unames <- unique(unlist(lapply(mylist, rownames)))
 
  n <- length(unames)
 
  out <- lapply(mylist, function(df) {
 
    tmp <- matrix(nr = n, nc = ncol(df), dimnames = list(unames,colnames(df)))
    tmp[rownames(df), ] <- as.matrix(df)
    rm(df); gc()
 
    return(tmp)
  })
 
  stopifnot( all( sapply(out, function(x) identical(rownames(x), unames)) ) )
 
  bigout <- do.call(cbind, out)
  colnames(bigout) <- paste0(rep(names(mylist), sapply(mylist, ncol)), unlist(sapply(mylist, colnames)))
  return(bigout)
}
 
